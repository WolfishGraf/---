'''
from scipy import stats
import numpy as np
a = np.array([185,175,170,169,171,172,175,157,170,172,167,173,168,167,166,
              167,169,172,177,178,165,161,179,159,164,178,172,170,173,171])

print("Мода:",stats.mode(a))# вычисление моды
print('Медиана:',np.median(a))# вычисление медианы
print("Среднее занчение:",np.mean(a))# вычисление среднего значения


#Расчитываем размах и стандартное отклонение с помощью numpy
print("Размах:", np.ptp(a)) # Название функции происходит от аббревиатуры "от пика к пику" (‘peak to peak’).
print(f'Стандартное отклонение: {np.std(a):.2f}')


#с помощью диаграммы boxplot мы можем узнать медиану, 2 и 3 квартиль
import matplotlib.pyplot as plt

plt.grid()# фон в линейку
plt.boxplot(a)
plt.show()


# Считается, что значение IQ (уровень интеллекта) у людей имеет нормальное распределение
#со средним значением равным 100 и стандартным отклонением равным 15 (M = 100, sd = 15).
#Какой приблизительно процент людей обладает IQ > 125?


from scipy import stats
mean = 100
std = 15
IQ=125
# sf - Survival function = (1 - cdf) - Функция кумулятивного распределения
print(f"Только у {(stats.norm(mean, std).sf(IQ))*100:.2f}% людей, IQ>{IQ}")

#Вычисление 1.96 c помощью scipy
# 95%
p = 0.95
# так как у нас двухсторонний интервал, сделаем вычисление
alpha = (1-p)/2
# isf - Обратная функция выживания (обратная к sf)
print(f'{stats.norm().isf(alpha):.2f} sigma')
'''
# из видео по статистике от А.Никулиной
import pandas as pd
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt
import math
import scipy as sc

#Столбцы:
#1 - фиксированная кислотность
#2 - летучая кислотность
#3 - лимонная кислотность
#4 - остаточный сахар
#5 - хлориды
#6 - свободный диоксид серы
#7 - общий диоксид серы
#8 - плотность
#9 - рН
#10 - сульфаты
#11 - алкоголь (градусы)
#выходные данные: 12 - качество (оценка от 0 до 10)

df = pd.read_csv('winequality-red.csv')

#ОПИСАТЕЛЬНЫЕ СТАТИСТИКИ
a = df.isnull().sum() #смотрим кол-во пропущенных элементов в столбцах

b = df.describe() # describe - описание

c = df['fixed acidity'].mean() # среднее значение в первом столбце

df['fixed acidity'].median()

# ГРАФИК КОЛ-НОГО РАСПРЕДЕЛЕНИЯ СТОЛБЦА
#Уменьшим интервал диапозона значений при помощи bins
#df['fixed acidity'].plot.hist(label = 'fixed acidity')
#df['fixed acidity'].plot.hist(bins = 50, label = 'fixed acidity') # зачсёт bins = 50 - уменьшили интервал, где мы считаем кол-ные значения в признаке

plt.figure(figsize=(10,4))
#sns.boxplot(df['fixed acidity'])
#plt.show()

# РАЗБРОС
#Для ГС это n, для выборки это n-1. ddof - дельта степеней свободы (n), ddof для ГС = 0, для выборки ddof=1
# ищем число степеней свободы для ГС
np.var(df['fixed acidity'], ddof=0 ) # дисперсия. ddof - показатель степеней свободы, по умолчанию 0 (для ГС)

#стандартное отклонение (корень из дисперсии) для ГС; для выборки среднеквадратическое отклонение
np.std(df['fixed acidity'], ddof=0)
# или
math.sqrt(np.var(df['fixed acidity'], ddof=0 ))

# ПРОВЕРКА ГИПОТЕЗ
#Нулевая гипотеза - распределение нормальное, альтренативная гипотеза - не имеет норм распределения

stat , p = sc.stats.shapiro(df['fixed acidity'])
alpha = 0.05
# вывели p => отклоняем гипотезу, т к слишком велико значение от альфы
#берём половину от выборки для того чего хотим, а вторую для сравнения
half = len(df['fixed acidity'])/2
sample1 = df.loc[:half,'fixed acidity']
sample2 = df.loc[half:,'fixed acidity']

#Нулевая гипотеза - средние равны, альтернативная - не равны
sc.stats.ttest_ind(sample1,sample2)
#sample2 p-критерий слишком мал => нулевую гипотезу отвергаем

#проверим это на графиках
plt.hist(sample1, bins = 50, label = 'sample1')
plt.hist(sample2, bins = 50, label = 'sample2')
plt.legend(loc = 'upper right')# какой цвет = какому графику + написали куда влепить обозначение

#смотрим медианы
"Медина сэмпла1:", np.median(sample1), '\nМедиана сэмпла2:',np.median(sample2)

# КОРРЕЛЯЦИЯ
#посмотри на таблицу с применённой корреляцией
df.corr()

sns.pairplot(df)# находит зависимости и корреляции в графическом виде
sns.heatmap(df.corr())#тепловой график корреляций










